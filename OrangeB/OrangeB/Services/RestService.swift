//
//  RestService.swift
//  OrangeB
//
//  Created by Víctor Varillas on 23/08/2018.
//  Copyright © 2018 VVL. All rights reserved.
//

import Foundation

open class RestService: NSObject, ServiceProtocol, URLSessionDataDelegate, URLSessionDelegate, URLSessionTaskDelegate {
    
    // MARK: - *** RestService ***
    fileprivate static var sharedInstance:RestService?
    
    // START CORE DATA SERVICE
    open static func start() {
        if sharedInstance == nil {
            let url:URL? = URL(string: "https://api.myjson.com/bins")!
            if url != nil && url!.host != nil {
                sharedInstance = RestService(baseurl: url)
            }
        } else {
            print("ERROR: RestService is trying to start 2 times");
        }
    }
    
    // STOP CORE DATA SERVICE
    open static func stop() {
        sharedInstance = nil
    }
    
    // CHECK IF SERVICE IS RUNNING
    open static func isRunning() -> Bool {
        return sharedInstance != nil
    }
    
    // MARK: - *** Public ***

    public enum HTTPMethods : String{
        case POST = "POST", GET = "GET", PUT = "PUT", DELETE = "DELETE"
    }
    
    /**
     Makes a rest call to a specific rest endpoint
     
     :param: The http method to call. See HTTPMethods
     
     :param: Rest endpoint, in the following format: "/rest/endpoint"
     
     :param: The completion closure(block) to call when this call is completed. This closure will return downloaded data if any, the url response that will contain the http coder and an eventual error generated by the network operation
     */
    
    open static func makeRestCall( _ method: HTTPMethods, restPoint: String, completionClosure:@escaping (_ data: Data?, _ response: URLResponse?, _ error: Error?)->Void ) {
        
        if sharedInstance != nil {
            sharedInstance?.makeRestCall(method, restPoint: restPoint, completionClosure: completionClosure)
            
        } else {
            let failureReason = "The makeRestCall was made while the service is not running"
            var dict = [String: AnyObject]()
            dict[NSLocalizedDescriptionKey] = "Failed to make the rest call" as AnyObject?
            dict[NSLocalizedFailureReasonErrorKey] = failureReason as AnyObject?
            let error = NSError(domain: "RestService_ERROR_DOMAIN", code: 1, userInfo: dict)
            completionClosure( nil , nil , error )
        }
    }
    
    // MARK: - *** Private ***
    fileprivate var baseurl:URL?
    fileprivate var session:Foundation.URLSession!
    
    fileprivate override init() {
        super.init()
    }
    
    fileprivate convenience init(baseurl: URL?) {
        self.init()
        self.baseurl = baseurl
        
        let sessionConfiguration = URLSessionConfiguration.default
        sessionConfiguration.requestCachePolicy = NSURLRequest.CachePolicy.reloadIgnoringLocalAndRemoteCacheData
        self.session = Foundation.URLSession(configuration: sessionConfiguration, delegate:self, delegateQueue:nil )
    }
    
    fileprivate func makeRestCall( _ method: HTTPMethods, restPoint: String, completionClosure:@escaping (_ data: Data?, _ response: URLResponse?, _ error: Error?)->Void ) {
        
        let url:URL = (baseurl?.appendingPathComponent(restPoint))!
        var request:URLRequest = URLRequest(url: url)
        request.httpMethod = method.rawValue
        request.setValue("application/json", forHTTPHeaderField: "Accept")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let task:URLSessionDataTask = self.session.dataTask(with: request, completionHandler: {(data, response, error) in
            completionClosure(data, response, error)
        })
        task.resume()
    }
    
    fileprivate func urlEncodeDictionay(_ dictionary:[String:String])->Data! {
        var parts:[NSString] = [NSString]()
        let allowedCharacterSet = (CharacterSet(charactersIn: "/%&=?$#+-~@<>|\\*,.()[]{}^!").inverted)
        
        for (key,value) in dictionary {
            let encodedKey = key.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet)
            let encodedValue =  value.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet)
            let part = (encodedKey! as String) + "=" + (encodedValue! as String)
            parts.append(part as NSString)
        }
        
        let array = parts as NSArray
        let encodedDictionary = array.componentsJoined(by: "&")
        return encodedDictionary.data(using: String.Encoding.utf8)
    }
    
    deinit {
        if self.session != nil {
            self.session.invalidateAndCancel()
            self.session = nil
        }
    }
    
    // MARK: - *** NSURLSessionDelegate ***
    open func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?)
    {}
    
    open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping (CachedURLResponse?) -> Void) {
        print("Delete cache")
    }
    
    // MARK: - *** NSURLSessionTaskDelegate ***
    open func urlSession(_ session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping (URLRequest?) -> Void)
    {}
    
    open func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) {
        print("Error \(String(describing: error))")
    }
    
}
